#!/usr/bin/perl 
#
# This script is for use with the Open Glider Network FLARM Detection System only
# Any other uses are NOT authorised
#
# Code has been sponsored by Temeletry Limited (http://www.temeletry.co.uk)
#
# Copyright (c) 2014, Melissa Jenkins, Temeletry Limited (melissa-ogn@temeletry.co.uk)
#
use strict;
use File::Copy;
use File::stat;
use Cwd;

# to make sure the file was downloaded properly
# md5sum d70a49430a45112b7b2a2c8d7824114d dYkZi4yjkHLeyd8I3mBeTUjFCUqnclHMnGnFo1PxOpQQdkc16PF4cHUkCLvkIAN4YN4Cdzv2wPIX8P2/jYAGJWbC9x04Vl7zjUlzOH6GMbjQNENAO0HkmgyaQOVEzavQIB2ggPHB8RRZuZenvkVrD+txlGPaXbPxSL8JRR7pO+LJe65c0ks7UZB8kQZQJlQyWsQTEpHTjDBPUi4XuZF88i23v3YDyQyOEHHvRNFVTWlGKn7g6hy9ybLnBLnmvdBI+pgg3GP/iDNVHpgWuFTts4zgnyq/gjSC58u8PygEX4TGmSGcSsDWwrGZ3xivYZkgvKXGsx8J68ijXqo5UzYPvQ==


my $version='1.4i';

my $old_handle = select (STDOUT);
$| = 1; # perform flush after each write to STDOUT
select ($old_handle);

my $scriptname = $0;
if( ! ($scriptname =~ m|^/| )) {
    $scriptname = cwd() . "/".$0;
    $scriptname =~ s|/./|/|;
}

# do they want help?
if( $ARGV[0] =~ '[-]+h' ) {
    print "$scriptname - OGN Updater v$version\n\n".
	"    -r      reboot after running.  If installing this will tell the crontab to issue a reboot \n".
	"            after it has checked for updates.  Service will not be restarted till after it boots.\n".
	"    -i      Do not start the service when done.\n".
	"    -t      Test, print what path, user and configuration file is being worked on.\n";
    exit 1;
}

if( $> != 0 ) {
    die "You need to run this as root, or use sudo";
}

# old style tokens
if( -e '/home/pi/sitetoken.txt' ) {
    move( '/home/pi/sitetoken.txt', '/etc/sitetoken.txt' );
}

# keep the same site id for the whole thing
my $token; my $aprscall = '*early';
if( ! -e "/etc/sitetoken.txt" ) {
    my $code = qx( /bin/dd if=/dev/urandom bs=1 count=8 status=noxfer 2>/dev/null );
    ($token) = join('-',unpack('H4 H4 H4', $code ));
    qx( echo $token > /etc/sitetoken.txt );
}
else {
    $token = qx( cat /etc/sitetoken.txt );
    chomp $token;
}

## exit when a script update is found
print "Checking for updates to update script ($scriptname, existing version $version)... ";
die "Unable to identify script name ($scriptname)" if( ! -e $scriptname );
{
    my $lasttime = stat($scriptname)->mtime;
    my $currenttime;
    my $tempname = '/tmp/update.'.date(time());
    system( "/usr/bin/curl -s -R -z $scriptname http://ognconfig.onglide.com/files/v1.4/update -# -o $tempname" );

    if( -e $tempname ) {
	$currenttime = stat($tempname)->mtime;
    }

    if( defined( $currenttime ) && $lasttime != $currenttime ) {

	my ($md5sum_calculated,$md5sum_expected,$signature);
	if( qx( /bin/grep -v '^# md5sum' $tempname | /usr/bin/md5sum ) =~ /^([0-9a-f]+) / ) {
	    $md5sum_calculated = $1;
	}

	if( qx( /bin/grep -e '^# md5sum' $tempname ) =~ /md5sum ([0-9a-f]+) (.*)/ ) {
	    $md5sum_expected = $1;
	    $signature = $2;
	}
	
	# if they are defined and the same
	if( defined( $md5sum_expected ) && $md5sum_expected eq $md5sum_calculated ) {

	    # we need to check to make sure we have our public key saved away, without this 
	    # we can't validate the identify
	    {
		open( OUT, '>', '/etc/flarmupdatekey.pem' ) || die "unable to write public key";
		print OUT "-----BEGIN PUBLIC KEY-----\n".
		    "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArG/od7cdIuhSvKXNbO80\n".
		    "tFncaCfwuKUrBGxGE6uxzXRfwcCIn8UukGTnzdMEErh441K+itC69KhgkEhY809K\n".
		    "sxKMJqZ2FL6lXdin7eIMpOKLIXKmwwRYyTYdChXbnrd3Y5e9BXOWEUJVsg2PYrDt\n".
		    "xQnm20PiUgQXVCoW0xuxCnltj69nWGdXWPwhvFYT2ulhIXfVivJmUvHESK2GbYTo\n".
		    "h2Fv7aIQACv4EK7UpPb9zPqBrV4MmwqAKP2LzycIdmlH9D1ebB9T2hK31MIegKuV\n".
		    "VWQFQyqzxnFou3n1WYN3RBe5VdPuabQGXe4VQGmJVR1/1GQ+rPLRaQYU2zDYdLi1\n".
		    "EQIDAQAB\n".
		    "-----END PUBLIC KEY-----\n";
		close( OUT );
	    }

	    # execute openssl to check signature
	    my $md5sum_signed = qx( echo "$signature" | /usr/bin/base64 -d | /usr/bin/openssl rsautl -verify -inkey /etc/flarmupdatekey.pem -keyform PEM -pubin );
	    chomp( $md5sum_signed );

	    # make sure it matches
	    if( defined( $md5sum_signed ) && $md5sum_signed eq $md5sum_calculated ) {

		# and that it isn't the same as the one we are running (datetime issue locally)
		my $current_md5sum = '';
		if( qx( /bin/grep -e '^# md5sum' $scriptname ) =~ /md5sum ([0-9a-f]+) (.*)/ ) {
		    $current_md5sum = $1;
		}

		if( $current_md5sum ne $md5sum_calculated ) {
		    copy( $tempname, $scriptname );
		    unlink( $tempname );
		    qx( /bin/chmod +x $scriptname );
		    status( "scriptupdate" );
		    print "an update has been found, restarting script.\n";
		    exec $scriptname, @ARGV ;
		}
		else {
		    print "already up to date, your time is wrong!\n";
		    status( "localdatetimeproblem" );
		}
	    }
	    else {
		print "invalid signature, not signed by correct key? ($md5sum_signed != $md5sum_calculated), not updating script.\n";
		status( "sig_problem,".($md5sum_signed||'?').','.($md5sum_expected||'?') );
	    }
	}
	else {
	    print "invalid checksum ($md5sum_expected != $md5sum_calculated), not updating script.\n";
	    status( "checksum_problem,".($md5sum_calculated||'?').','.($md5sum_expected||'?') );
	}
    }
    else {
	print "up to date.\n";
	status("uptodate,".($currenttime||'-').",$lasttime");
    }

    if( -e "$tempname" ) {
	unlink( $tempname );
    }
}

## Make sure we have the correct procServer configuration file before we do anything as it 
# won't work without it!
if( ! -e '/etc/rtlsdr-flarm.conf' ) {
    status( 'noconfig' );
    die "Unable to find /etc/rtlsdr-flarm.conf\n";
}

if( $ARGV[0] eq '-t' ) {
    status( "testing" );
}

print "Checking automatic updater is installed...";
my $check = qx( /usr/bin/crontab -u root -l );
if( $check =~ /update/ ) {
    print "yes.\n";
}
elsif( $ARGV[0] eq '-t' ) {
    print "no. testing only\n";
}
else {
    # if we are installing and have been asked to do a reboot after running
    # then we will add the -r flag to the crontab
    my $reboot = '';
    if( $ARGV[0] eq '-r' ) {
	$reboot = '-r';
    }
    my $when = sprintf( "%d %d", int(rand(59)), (int(rand(7))+23)%24 );
    open( OUT, "| /usr/bin/crontab -u root -" ) || die "unable to write to crontab to install";
    print OUT $check;
    print OUT "$when * * * $scriptname $reboot\n";
    close( OUT );
    $when =~ s/ /:/;
    status( "crontab/$when" );
    print "installed.\n";
}

# what we read from the configuration file
my %config;
my @config_order;
my %config_description;

# next check for daemon startup script and extra details from that
my $installdirectory;
my $username;
my $configfile;# if you need to copy it from /tmp/rtlsdr-flarm.site.conf after the upgrade

my $os; my $processor;

{
    open( my $fh, '<', "/etc/rtlsdr-flarm.conf" ) || die "Unable to read /etc/rtlsdr-flarm.conf";
    while( <$fh> ) {
        my $line = $_;
        chomp $line;
        if( $line =~ m|^50000\s+([a-z0-9_-]+)\s+([a-z0-9/._-]+)\s+([a-z0-9/._-]+)\s+([a-z0-9/._-]+)|i ) {
            $installdirectory = $2;
            $username = $1;
            $configfile = $4;
        }
    }

    # sanity check
    if( ! ($installdirectory =~ m|/rtlsdr-flarm$|) ) {
	status('failed/idir');
	die "Please change your /etc/rtlsdr-flarm.conf to point to the rtlsdr-flarm directory rather than a version specific directory.";
    }

    # remove the rtlsdr as this is included in the original distributions
    my $installeddirectory = $installdirectory;
    $installdirectory =~ s/rtlsdr-flarm$//;
    $installdirectory =~ s|/$||;

    # exactly where is the config file, find it the same way the flarm process would - change into the directory
    # and then convert to an absolute path
    chdir $installeddirectory;
    my $expandedconfigfile = Cwd::abs_path( $configfile );
    copy( $expandedconfigfile, "/tmp/rtlsdr-ogn.conf.site" );
    chdir $installdirectory;

    print "$expandedconfigfile\n";
    read_config();
    $aprscall = $config{APRS_Call}||'unknown';
    $aprscall =~ s/"//g;

    # make sure the device has been configured, if not then don't do anything
    if( $aprscall eq 'Example' || $aprscall eq 'unknown' ) {
	status( "failed/unconfigured" );
	die "This device has not yet been configured.\nPlease edit $expandedconfigfile\n".
	    "If you are using an image from http://ognconfig.onglide.com or the bootstrap you should complete configuration before running this.\n".
	    "If the update script has been installed then it will automatically retry the update every night.\n";
    }

    # next step is to check which install it is
    $processor = qx( /bin/uname -p );
    $os = qx( /bin/uname -a );
    my $download;
    my $filename;
    my $dist;

    if( -e '/etc/init.d/flarm-update' ) {
	print "Disabling old updater...";
	if( $ARGV[0] ne '-t' ) {
	    status("old_disabled");
	    qx( /usr/sbin/update-rc.d flarm-update remove 2>/dev/null);
	    unlink "/etc/init.d/flarm-update";
	    print "done.\n";
	}
	else {
	    print "skipped... testing\n";
	}
    }

    # add the ogn user
    qx( /usr/sbin/useradd -m -G `groups|tr ' ' ,` ogn 2>/dev/null );

    if ( ! -e '/home/ogn' ) {
	mkdir '/home/ogn';
	qx( /bin/chown ogn:ogn /home/ogn );
    }

    # copy the configuration file over
    print "preparing for 2.0 update... \n";

    # disable old process
    qx( /usr/sbin/service rtlsdr-flarm stop );
    qx( /usr/sbin/update-rc.d rtlsdr-flarm remove );
    unlink( '/etc/init.d/rtlsdr-flarm' );
#    unlink( '/etc/rtlsdr-flarm.conf' );

    # download the new startup scripts
    qx( /usr/bin/curl 'http://ognconfig.onglide.com/files/v2.0/rtlsdr-ogn' -R -# -o /etc/init.d/rtlsdr-ogn );
    qx( /usr/bin/curl 'http://ognconfig.onglide.com/files/v2.0/rtlsdr-ogn.conf' -R -# -o /etc/rtlsdr-ogn.conf );

    qx( /bin/chmod +x /etc/init.d/rtlsdr-ogn );
    qx( /bin/chown ogn /home/ogn/rtlsdr-ogn.conf );

    # download the new updater, it will actually do the installation
    qx( /usr/bin/curl 'http://ognconfig.onglide.com/files/v2.0/update' -R -# -o /home/ogn/update );

    # enable new process
    qx( /usr/sbin/update-rc.d rtlsdr-ogn defaults );

    # copy only the config we want accross
    remove133config();
    write_config();

    # remove the old crontab and then use the installer to configure a new one - this MAY
    # not return!
    print "Launching updater for version 2.0 to do installation\n";
    qx( echo '' | /usr/bin/crontab -u root - );
    qx( /bin/chmod +x /home/ogn/update  );
    system( "/home/ogn/update -i" );

    # now download the configure script and run it this will fetch the correct configuration for this site
    # from the website

    print "\n\n*** rebooting now ***\n";
    status( "reboot" );
    qx( /sbin/reboot );
}

sub read_config {
    my @sections;

    # if the configuration file is empty or doesn't exist then we need to 
    if( ! -e '/tmp/rtlsdr-ogn.conf.site' || -z '/tmp/rtlsdr-ogn.conf.site' ) {
	print "Copying Template.conf as configuration file appears to be missing\n";
	status( "using_template.conf" );
	copy( '/home/ogn/rtlsdr-ogn/Template.conf', '/tmp/rtlsdr-ogn.conf.site' );
    }
	

    # read it into the hash
    open( my $fh, '<', "/tmp/rtlsdr-ogn.conf.site" ) || die "unable to open configuration file";
    while( <$fh> ) {
	my $line = $_;
	chomp $line;
	if( $line =~ /^\s*([A-Za-z]+):/ ) {
	    push @sections, $1;
	    push @config_order, "+$1";
	}

	if( $line =~ /^\s*}/ ) {
	    pop @sections;
	    push @config_order, "-$1";
	}

	if( $line =~ /([A-Za-z]+)\s*=\s*([^;]+)(.*)/ ) {
	    my $key = join('_',@sections,$1);
	    $config{$key} = $2;
	    $config_description{$key} = $3;
	    push @config_order, "=$key,$1"; # so we know what order to write in
	}
    }
    close ($fh);

    # send the status to the server
    status( "read", 'configuration', '/home/ogn/rtlsdr-ogn.conf' );
}

sub remove133config {

    my $skip = 0;
    @config_order = grep {

	my $k = $_;
	$skip = 1 if( $k =~ /[+](Flarm|Demodulator|HTTP)/i ); # drop whole sections
	
	my $keep = ! $skip;

	# keys we don't want
	$keep = 0 if( $k =~ /(SensTime|Icon|Server|BeaconInterval|OfsTune)/ );
	
	$skip = 0 if( $k eq '-' );
	$keep;
    } @config_order;
}

sub write_config {
    my $depth = '';
    my $first =0;
    copy( '/home/ogn/rtlsdr-ogn.conf', '/home/ogn/rtlsdr-ogn/rtlsdr-ogn.conf.'.date(time()));
    
    if( ! open( FH, '>', "/home/ogn/rtlsdr-ogn.conf" ) ) {
	status( "cfgwritefailed,$!" );
	die "unable to open configuration file";
    }

    foreach my $key ( @config_order ) {
	my $action = substr($key,0,1);
	my $id = substr($key,1);
	
	if( $action eq '+' ) {
	    print FH $depth.$id . ":\n".$depth.'{';
	    $depth .= '  ';
	    $first = 1;
	}
	elsif( $action eq '-' ) {
	    $depth = substr($depth,0,-2);
	    print FH $depth."} ;\n";
	}
	elsif( $action eq '=' ) {
	    my ($k,$i) = split( ',', $id );
	    if( $first ) {
		print FH ' ';
	    }
	    else { 
		print FH $depth;
	    }
	    print FH $i . "=" . $config{$k} . $config_description{$k}."\n";
	    $first = 0;
	}
    }

    close(FH);

    status( "writeconfiguration" );

    # make sure we can read the newly written file
    qx( /bin/chown ogn:ogn /home/ogn/rtlsdr-ogn.conf );
	    

}

sub status {
    my ($status) = @_;
    qx( /usr/bin/curl -s "http://ognconfig.onglide.com/perl/startupgrade.pl?token=$token/v$version\&status=$status\&call=$aprscall" );
}


sub date {
    my @t = gmtime($_[0]);
    return sprintf( "%04d-%02d-%02dT%02d-%02d-%02d", ($t[5]+1900),($t[4]+1),$t[3],$t[2],$t[1],$t[0]);
}

